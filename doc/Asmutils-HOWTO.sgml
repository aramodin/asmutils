<!doctype linuxdoc system>

<!-- $Id: Asmutils-HOWTO.sgml,v 1.3 2000/09/03 16:25:07 konst Exp $ -->

<article>

<title>Asmutils HOWTO

<author>
<url url="mailto:konst@linuxassembly.org" name="Konstantin Boldyshev">

<date>v0.3, August 23, 2000

<abstract>
This is the Asmutils HOWTO.

This document is to accompany asmutils, explain asmutils internals,
describe how to write asmutils program and how to contribute to the project.

It targets asmutils developers and advanced users
striving for the secret lore of the assembly entity.
</abstract>

<toc>

<sect>Introduction
<p>

<sect1>Legal blurb
<p>
Copyright &copy; 1999-2000 Konstantin Boldyshev.
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU <url url="http://www.gnu.org/copyleft/fdl.html"
name="Free Documentation License">, Version 1.1
or any later version published by the Free Software Foundation.

<sect1>Credits
<p>

I would like to thank following persons for contributing to this document:

<itemize>
<item>Brian Raiter (elf.inc description)
<item>Dmitry Bakhvalov (using gdb)
</itemize>

<sect1>Before you begin
<p>

I assume you are familiar with Unix and assembly language to an extent
when you are able to understand what is written here.
If you are not understanding most of what is written here,
probably this HOWTO is not for you.

I expect that you will dig in and examine source code of asmutils.
This document is not intended to replace the source, its goal is only
to accompany asmutils source and explain some unclear moments.
Again, examine ALL source code. Look how command line parsing is done,
how conditional assembly for different kernel versions is done and so on --
I am not going to explain all and everything here.

This HOWTO deals with compiling, developing, debugging, contributing issues,
it shows some tricks you can use;
also it describes a set of macros I've developed to write fast and readable;
they are hiding from you unneeded details,
and take care of optimization.

You may also want to read other documentation represented at the
<url url="http://linuxassembly.org" name="Linux Assembly"> site
to get better general (not asmutils specific) understanding
of asmutils source code.

<sect1>Compiling asmutils
<p>

Asmutils are build with the usual compile suite and <tt/nasm/.
Except <tt/nasm/ you will need
<tt/make/, <tt/ld/, <tt/sh/, <tt/ln/, <tt/rm/,
possibly <tt/strip/ and something else, depending on your OS.

Preferred program versions are:

<itemize>
<item>nasm 0.98
<item>ld from GNU binutils 2.9 (on Linux)
<item>GNU make 3.77
</itemize>

Older/other versions may work too.
GNU <tt/make/ is required, on BSD systems it is usually called <tt/gmake/.

All compile-time configuration is in the <tt/MCONFIG/ file,
which has enough comments to figure out what you can do.
You can try to fallback to libc functions instead of using direct
system calls by defining OS=LIBC in <tt/MCONFIG/ if your really want to do so;
then you will also need <tt/gcc/ and libc headers.

<em/Note: several utils (cpuinfo, eject, httpd, kill, etc)
have their own additional configuration in the source code./

<sect>Program structure
<p>
There are three macros that make section definition as simple as possible:
<tt/CODESEG/, <tt/DATASEG/ and <tt/UDATASEG/
(similar to <tt/tasm/ ideal mode syntax).
<tt/END/ macro marks end of file.

Program must have at least <tt/CODESEG/ (.text) section, other sections are optional.
<tt/CODESEG/ is read-only, <tt/DATASEG/ and <tt/UDATASEG/ are read-write;
i.e. you can place data in <tt/CODESEG/ as long as you will not change it.
You can also define your own sections if you want, but there's very rare need
of doing so. Each section (even if it is empty) will enlarge your file.

<tt/START/ macro tells linker the entry point, and MUST be present.

So, program skeleton will look like:

<code>
%include "system.inc"

CODESEG

START:			;entry point

    your_code_here

DATASEG

    your_data_here

UDATASEG

    your_bss_here

END
</code>

<sect>Include files description

<sect1>system.inc
<p>

This file is vital and MUST be included into program code to do anything else;
without this file you'll have to write in usual boring way.

<tt/CODESEG/, <tt/DATASEG/, <tt/UDATASEG/, <tt/END/, <tt/I_STRUC/, <tt/I_END/
macros are here, some other will be added.

Also it contains optimizing macros <tt/_mov/, <tt/_add/, <tt/_sub/,
that perform register assignment, addition and subtraction.
You can use these macros instead of mov, add, sub instructions --
if you take care of size, this will produce quite good results
(do not try to understand how they work :).
<em>
Note: when passing negative number in -0x80..0x00 range to <tt/_mov/,
pass it as hex, i.e. 0xffffffff instead of -1, if you want size optimization.
This is a "feature" of <tt/nasm/, not <tt/_mov/ bug.
</em>

This file includes two others:
<ref id="inc-includes" name="includes.inc"> and
<ref id="inc-syscall" name="syscall.inc">,
you do need to include them manually.

<sect1>includes.inc<label id="inc-includes">
<p>

This file stores generic constant definitions and structures
(from libc headers), that are OS independent.
If you add some defined constant,
please do not forget to mention header file it was taken from.

<sect1>syscall.inc<label id="inc-syscall">
<p>
File holds system call macros, here are general things to know them:
(<bf>warning: from asmutils 0.11 syscall macros will change seriously!</bf>)

<itemize>
<item>there can be up to 5 parameters (depends on syscall)
<item>all parameters are always optional
<item>registers corresponding to parameters are: ebx (1), ecx (2), edx (3), esi (4), edi (5)
<item>registers are not touched, except eax, which holds return code
<item>eax is used as syscall (function) number and is always destroyed; after call it contains return value
<item>ecx and edx also can be destroyed by several system calls (at least on Linux)
<item>flags can be touched, you should not assume that flags are the same after call
<item>if there are no parameters, macro assumes that all registers (except eax) are already set before syscall
<item>number of used registers is equal to number of passed parameters + 1 (eax)
<item>parameter can be register, memory address, reference, constant or reserved word
<item>reserved words are (currently only one): EMPTY
(indicates that register is already set before macro and must be skipped).
It is useful when you need to pass only  say third parameter
and not touch others; f.e. <tt/sys_write EMPTY,EMPTY,1/ will expand to:

<tscreen><code>
	_mov edx,1
	__syscall write...
</code></tscreen>

<item>
registers are set in this order: edi, esi, edx, ecx, ebx, eax;
i.e. it is possible to write <tt/sys_write eax, ebx, ecx/;
it will expand to:

<tscreen><code>
	mov	edx,ecx
	mov	ecx,ebx
	mov	ebx,eax
	__syscall write...
</code></tscreen>
<item>generated code can be optimized for size (default) or speed
</itemize>

<bf/WARNING:/ *never* use <tt/__syscall/ macro in your program directly
(of course the same applies to int 0x80 !!).
This is a VERY BAD thing to do.
This will MAKE YOUR CODE UNPORTABLE!
So please use only <tt/sys_xxx/ macros!

If some system call is missing, you can add it to this file;
it's simple, just look how others are done there;
use sys_syscallname as macro name.


<sect1>elf.inc<label id="inc-elf">
<p>

<bf/This file applies only to Linux./ ELF macros are defined here.
These macros can be (and are, by default) used to reduce final size of executable.
Almost all of them (except ELF_BSTRUC and ELF_AT)
are integrated into existing program structure.
To enable them you just need to have <tt/ELF_MACROS = y/ line in <tt/MCONFIG/ (enabled by default),
this turns on automatic usage of these macros (and you do not have to include elf.inc).
And if you will follow simple rules when writing a program,
then you will not have to carry out two different definitions for sections and structures;
so, you can compile the same source with and without usage of these macros,
getting correct code in both cases.
This is experimental thing, however it seems to work well.
Rules are simple: use following section order: CODESEG, DATASEG, UDATASEG, END,
and use I_STRUC and I_END to define structures in UDATASEG
instead of <tt>istruc</tt> and <tt>iend</tt> (take any asmutils source as an example).
Alternatively, you can use macros from elf.inc directly if you want,
but then you can't compile your source using usual nasm/ld procedure.
If you want to go this way, take the time and read REAME.elf carefully
(also do read it if you want to understand how they work).
Personally I think that first way is simpler.

Brian Raiter wrote the description below and comments in elf.inc 
containing all you need to know about what they do and how they work.

<tscreen><code>
	elf.inc macros description (by Brian Raiter)
	--------------------------------------------

ELF executable files can contain a great deal of overhead information.
This overhead is used to define things such as the program's memory
layout, dynamic libraries which it needs in order to run, and so on.
The programs in asmutils, however, require almost none of this
overhead (e.g., by making direct system calls). This permits the
programs to be much smaller than they would be otherwise. In fact,
they require less ELF overhead than Nasm and ld expect of any program.
As a result, these tools create executables with unnecessary overhead.
Some of this overhead can be removed afterwards using strip and/or
sstrip, but not all of it.

Therefore, as of version 0.05, the asmutils programs avoid using
object files entirely, and instead define the ELF executable file
images directly, byte for byte, using Nasm's "bin" output file format
and the macros defined in elf.inc. These macros are defined here.


BEGIN_ELF
END_ELF

These are the two main macros in elf.inc. They mark the beginning and
the end of the program, and must be used together. All assembler
instructions (and pseudo-instructions such as "DB") should appear
between these two macros.

Within these two macros, the START label should be defined, which will
mark the entry point of the program.

BEGIN_ELF uses the ORG pseudo-instruction to indicate where the file
is to be loaded in memory, and then defines a minimal ELF header and
program header table. BEGIN_ELF also defines the label _text to point
to the area immediately following its usage (which is typically the
beginning of the program).

Note that if instructions do appear after the END_ELF macro, they will
still be added to the executable file. However, nothing after END_ELF
will be loaded into memory when the program is executed.

If the program requires no writable data storage outside of the
stack, then nothing else from elf.inc will be needed.


ELF_DATA

This macro is used to reserve writable memory. ELF_DATA should appear
after the program proper, and before END_ELF. Between these two
macros, the programmer can define "uninitialized" data using the
RESB family of pseudo-instructions.

Memory defined in the ELF_DATA section will not take up space in the
executable file, but will instead be automatically allocated at
runtime. The data will be initialized to all zeros. The builtin macro
ALIGNB may also be used here.

ELF_DATA also defines the label _data to point to the area immediately
following its usage.

Note: do not use the DB family of pseudo-instructions within the
ELF_DATA section; those should appear before ELF_DATA, within the
program proper.


ELF_BSTRUC strucname [, fieldname ...]

This macro declares an instance of a structure (previously defined
with the builtin STRUC macro) within an ELF_DATA segment. The
structure, in order to work with ELF_BSTRUC, must have been defined
using local labels (i.e., prefixed with a dot) for the field names.

The first argument to ELF_BSTRUC is the name of the structure to use.
The remaining arguments (if any) list the field names to declare. Only
those field names specified will be declared as labels within the
program.

Thus, for example, if the following structure has been defined:

          struc mytype 
.long:    resd 1 
.word:    resw 1 
.byte:    resb 1 
.str:     resb 32 
          endstruc

then a program that included the following after ELF_DATA:

mine:     elf_bstruc mytype .long, .word, .str

would have 39 bytes added to its memory image, and could use the
labels mine.long, mine.word, and mine.str. (mine.byte would not be
created.)


ELF_ISTRUC strucname
ELF_IAT fieldname [, inst ...]
ELF_IEND

These macros correspond directly to the builtin macros ISTRUCT, AT,
and IEND; they differ only in that they declare "uninitialized"
memory, and thus can be used within an ELF_DATA section.
</code></tscreen>

</p>

<sect>Debugging your code
<p>

<sect1>gdb
<p>

Although <tt/gdb/ is source-level debugger, it can be used to debug
pure assembly code (the simplest way is to place <tt/int 3/ instructions
as breakpoints over your code).
And with some trickery you can force <tt/gdb/ to do what you want:

<tscreen><verb>
Using GDB with asmutils (by Dmitry Bakhvalov)
--------------------------------------------

Personally, I use gdb for debugging asmutils. Try this:
 
1) Use the following stuff to compile:
   $nasm -f elf -g smth.asm
   $ld -o smth smth.o

2) Fire up gdb:
   $gdb smth

3) In gdb:
   (gdb) disassemble _start
   Place a breakpoint at <_start+1> (If placed at _start the breakpoint
   wouldn't work, dunno why)
   (gdb) b *0x8048075

   To step thru the code I use the following macro:
   (gdb)define n
   >ni
   >printf "eax=%x ebx=%x ...etc...",$eax,$ebx,...etc...
   >disassemble $pc $pc+15
   >end

   Then start the program with r command and debug with n.

   Hope this helps.
</verb></tscreen>

<tscreen><verb>
An additional note from ???
---------------------------

    I have such a macro in my .gdbinit for quite some time now, and it
    for sure makes life easier. A small difference : I use "x /8i $pc",
    which guarantee a fixed number of disassembled instructions. Then,
    with a well chosen size for my xterm, gdb output looks like it is
    refreshed, and not scrolling.
</verb></tscreen>

<sect1>strace
<p>
Definitely <tt/strace/ can help you a lot (<tt/ktrace/ and <tt/kdump/ on FreeBSD),
it is used to trace system calls and signals.
Read its manual page (<tt/man strace/) and <tt/strace --help/ output for details.


<sect>Contribution guidelines
<p>
Asmutils would never become what they are without submissions
from various hackers. As any open project, it relies much
on contributions. Hence, if you've got an intention/inspiration
to contribute something, you're more than welcome!

So, if you are the person who follows the challenge of UNIX
assembly programming and wants your code to be included
into asmutils, do examine this section carefully.
It contains extremely important information, your contribution
may not be accepted if you ignore suggestions below.

Although I think most of what is said in this section is evident
to experienced developers of distributed free software, there might be
brand new developers from the proprietary software world, unaware of common
contribution practice; if you are the one, read with double attention.

<sect1>First step
<p>
<bf/Before you begin/ make sure you are using <bf/the latest/
version of asmutils, I can reject contributions based on old versions.

So, get the latest version of asmutils and look what is already done.
Even if the program you want to contribute is not there, look at
<url url="http://linuxassembly.org/asmutils.html" name="ChangeLog">, or
CVS <tt>cvs.linuxassembly.org:/cvsroot/asm</tt> (using ssh and pserver,
module name is &quot;asmutils&quot;), or contact maintainer first,
may be somebody is already doing (or has done)
what you're only going to do (ditto if you want to improve existing utils).
This is very important! Asmutils are growing rapidly,
do not duplicate effort of other hackers.

<sect1>Source code requirements
<p>
Here are few obvious requirements for the source code:

<itemize>
<item>you must use <tt/nasm/ assembler
<item>you must use supplied macro set
<item>you must not use libc or any other external library
</itemize>

<em>
Note: I can accept utilities written in <tt/gas/, but this will give me just more
boring work of converting them to <tt/nasm/ syntax and asmutils macro set.
This is to be avoided when possible. I mean, do it on your own :)
</em>

While writing your program take care of portability!
Basically, this means:

<itemize>
<item>no int 0x80 (or similar) calls directly, only sys_xxx macros
<item>no ELF or kernel specific bizarre hacks, such as self-modifying code, writable CODESEG, etc.
<item>no 0 instead of STDIN, 9 instead of SIGKILL, and so on
</itemize>

I think you've got an idea. Just try to imagine your program on other OS,
and ask yourself: what one will need to do make it run?
what should I do to make compile on as many OSes as possible?
Even your program is OS specific (f.e. lsmod),
at least try to make it readable.

<bf/I reject submissions eliminating these simple rules./

And of course, your code must do something useful, not just be written
according to the above requirements :). Usual UNIX utils are preferred,
but you can also contribute your very own program.
Keep in mind that asmutils are not just fun. They are used
in (and targeted on) small distributions and embedded systems.
Thus, they should be as small as possible, use very few memory,
and be fast as kernel. Neither more, nor less :)

<sect1>Last step
<p>
When, finally, you think your program is ready,
here again comes administrativia.

First, try to test your program. If it still works, rest a day, then look
at it again.. I mean, I know you're very excited that your program works,
but just try to look what now you can improve; do not send maintainer a new
version every day, this will save him (and you) from the mess of versions.

New programs should be sent to project maintainer, while improvements
of existing -- to particular util maintainer first.

Since asmutils programs are usually quite small, please send
full source of program instead of patches when possible.

Sometimes maintainer (or I) will modify your code a bit.
Please use that modified code for next program version.

Simple, huh? :)

With any additional questions refer to the asmutils webpage
or contact asmutils maintainer.

<sect1>Porting
<p>
asmutils are quite portable to any i386 (POSIX/UNIX) OS;
if you are interested in asmutils running on your OS, I am willing to help.
However of course I will need that OS, so you will have to donate me CD's
(do not ask me to download gigs from the net!).
Drop me a mail if you are interested.


<sect>Optimization, tips and tricks
<p>

In fact optimization must be done by assembler.. but..
optimizing assembler is just a sweet dream yet. So, I've took care of it.
By default code is optimized for size, and you can get up to 20% smaller executable;
speed optimization in fact is a fake, it's just an absence of size optimization :),
though theoretically you can gain something on pentium processors..
To enable speed optimization set OPTIMIZE to SPEED in <tt/MCONFIG/.
Optimization touches register assignment, addition and subtraction
(<bf/_mov/, <bf/_add/, <bf/_sub/ macros),
and section alignment (<bf/CODESEG/, <bf/DATASEG/ macros).
Optimization is a work in progress, so results may be better in future versions.

If you've gone crazy on binary size,
you may want to use some of things described below.

First of all, try to keep your program in one <bf/CODESEG/ (.text) section.
Remember, every new section (even if it is empty) increases size of executable file.
Unless you have any <em/read-write/ data, do not create <bf/DATASEG/ (.data section), keep your data in <bf/CODESEG/.
Even if you've got one/two variables with assigned initial values, first think of keeping them dynamically on the stack instead of creating <bf/DATASEG/.
And if your initial value is zero, place such variable in <bf/UDATASEG/ (.bss) section, it will be zeroed out by kernel.

Use <bf/_mov/ macro instead of <tt/mov/ instruction
(if you do not assign one register to another),
this will track several special cases and produce smaller code.

Avoid using 16bit registers (ax, bx, cx, etc) unless you know exactly what you're doing.
Every 16bit instruction will take one more byte (0x66 prefix).
For instance, <tt/inc ax/ will produce greater code than <tt/inc eax/.

Here are some assembly examples you can use instead of
<tt/cmp/ instruction to produce smaller code:

<tscreen><code>
;if eax < 0 (signed compare)

	test	eax,eax
	js	is_less

;if eax == 0

	test	eax,eax
	jz	is_zero

;if eax == 0

	or	eax,eax
	jz	is_zero

;if eax == 1		(and you no more care of its value)

	dec	eax
	jz	is_one

;if eax == 2		(and you no more care of its value)

	dec	eax
	dec	eax
	jz	is_one


;if eax == -1		(and you no more care of its value)

	inc	eax
	jz	is_minus_one

;if eax == -2		(and you no more care of its value)

	inc	eax
	inc	eax
	jz	is_minus_one


;if -255 < value < 255, you can use

	cmp	eax,byte value ;or -value

;instead of
	cmp	eax,value
</code></tscreen>

Seek, and you may find more..

$Id: Asmutils-HOWTO.sgml,v 1.3 2000/09/03 16:25:07 konst Exp $

</article>
