
	elf.inc macros description (by Brian Raiter)
	--------------------------------------------

ELF executable files can contain a great deal of overhead information.
This overhead is used to define things such as the program's memory
layout, dynamic libraries which it needs in order to run, and so on.
The programs in asmutils, however, require almost none of this
overhead (e.g., by making direct system calls). This permits the
programs to be much smaller than they would be otherwise. In fact,
they require less ELF overhead than Nasm and ld expect of any program.
As a result, these tools create executables with unnecessary overhead.
Some of this overhead can be removed afterwards using strip and/or
sstrip, but not all of it.

Therefore, as of version 0.05, the asmutils programs avoid using
object files entirely, and instead define the ELF executable file
images directly, byte for byte, using Nasm's "bin" output file format
and the macros defined in elf.inc. These macros are defined here.


BEGIN_ELF
END_ELF

These are the two main macros in elf.inc. They mark the beginning and
the end of the program, and must be used together. All assembler
instructions (and pseudo-instructions such as "DB") should appear
between these two macros.

Within these two macros, the START label should be defined, which will
mark the entry point of the program.

BEGIN_ELF uses the ORG pseudo-instruction to indicate where the file
is to be loaded in memory, and then defines a minimal ELF header and
program header table. BEGIN_ELF also defines the label _text to point
to the area immediately following its usage (which is typically the
beginning of the program).

Note that if instructions do appear after the END_ELF macro, they will
still be added to the executable file. However, nothing after END_ELF
will be loaded into memory when the program is executed.

If the program requires no writeable data storage outside of the
stack, then nothing else from elf.inc will be needed.


ELF_DATA

This macro is used to reserve writeable memory. ELF_DATA should appear
after the program proper, and before END_ELF. Between these two
macros, the programmer can define "uninitialized" data using the
RESB family of pseudo-instructions.

Memory defined in the ELF_DATA section will not take up space in the
executable file, but will instead be automatically allocated at
runtime. The data will be initialized to all zeros. The builtin macro
ALIGNB may also be used here.

ELF_DATA also defines the label _data to point to the area immediately
following its usage.

Note: do not use the DB family of pseudo-instructions within the
ELF_DATA section; those should appear before ELF_DATA, within the
program proper.


ELF_BSTRUC strucname [, fieldname ...]

This macro declares an instance of a structure (previously defined
with the builtin STRUC macro) within an ELF_DATA segment. The
structure, in order to work with ELF_BSTRUC, must have been defined
using local labels (i.e., prefixed with a dot) for the field names.

The first argument to ELF_BSTRUC is the name of the structure to use.
The remaining arguments (if any) list the field names to declare. Only
those field names specified will be declared as labels within the
program.

Thus, for example, if the following structure has been defined:

          struc mytype 
.long:    resd 1 
.word:    resw 1 
.byte:    resb 1 
.str:     resb 32 
          endstruc

then a program that included the following after ELF_DATA:

mine:     elf_bstruc mytype .long, .word, .str

would have 39 bytes added to its memory image, and could use the
labels mine.long, mine.word, and mine.str. (mine.byte would not be
created.)


ELF_ISTRUC strucname
ELF_IAT fieldname [, inst ...]
ELF_IEND

These macros correspond directly to the builtin macros ISTRUCT, AT,
and IEND; they differ only in that they declare "uninitialized"
memory, and thus can be used within an ELF_DATA section.
