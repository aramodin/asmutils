<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (X11; I; Linux 2.2.13ac1 i686) [Netscape]">
</head>
<body>
&nbsp;
<br>
<hr WIDTH="100%">
<h3>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#990000">&nbsp;
1 -&nbsp; <b>CLIB</b></font></h3>

<p><br>&nbsp;&nbsp;&nbsp; I had talked to you of my clib I release for
my OS...I have made a version for linux that can be used with C style call
or ASM style calls(regs)...
<br>I have modified It , including a lot of conditionnal assembly... I
have defined two var for call style:
<br>it is at the beginning of the source:
<br>&nbsp;&nbsp;&nbsp; C_CALL is for C style passing of args on stack
<br>&nbsp;&nbsp;&nbsp; ASM_CALL is for asm call style through registers
<p>the second flags are:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SPEEDOPT&nbsp; for speed
optimization
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SIZEOPT for guess what ???&nbsp;
yes size optimization
<p>for the moment , you have to choose between SIZEOPT or SPEEDOPT&nbsp;
not the two at the same time..
<br>idem for C_CALL or ASM_CALL
<br>&nbsp;&nbsp;&nbsp; to set the flags you just have to uncomment the
related line at the beginning of the source
<p>&nbsp;&nbsp;&nbsp; OK here is the functions implemented in this first
version...:
<p>&nbsp;&nbsp;&nbsp; itoa
<br>&nbsp;&nbsp;&nbsp; strlen
<br>&nbsp;&nbsp;&nbsp; memset
<br>&nbsp;&nbsp;&nbsp; memcpy
<br>&nbsp;&nbsp;&nbsp; memcpyl
<br>&nbsp;&nbsp;&nbsp; fprintf
<br>&nbsp;&nbsp;&nbsp; printf
<br>&nbsp;&nbsp;&nbsp; malloc
<br>&nbsp;&nbsp;&nbsp; calloc
<br>&nbsp;&nbsp;&nbsp; free
<p>&nbsp;&nbsp;<u><font color="#3366FF">&nbsp; first:&nbsp;&nbsp; the memory
allocation trio (malloc, free, calloc) &amp; MemInit</font></u>
<p>&nbsp;&nbsp;&nbsp; the memory allocation trio (malloc,free,calloc)&nbsp;
were developped for my OS first, I have tested them extensively , and I
am proud of them , because they are pretty fast &amp; short...I think they
are pretty sure too , no bugs...
<br>&nbsp;&nbsp;&nbsp; The memory allocation scheme , use a sort of linked
list... each memory block size is 12 bytes
<br>structured like this...:
<p>struc MAB
<br>&nbsp;&nbsp;&nbsp; .start resd 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; begginning of block (divide by 32, starting at 0&nbsp; first location
of the mem space)
<br>&nbsp;&nbsp;&nbsp; .size resd 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; the size of the mem block (divide by 32 too)
<br>&nbsp;&nbsp;&nbsp; .pid resd 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; the pid&nbsp; of the process which allocate the block
<br>endstruc
<p>&nbsp;&nbsp;&nbsp; the memory allocated block sizes are 32 bytes multiple,
I could have made 1 byte memory block ,&nbsp; but I think that 32 byte
is good like that , it is always aligned on a cache line boundary, and
it avoid memory fragmentation...
<br>&nbsp;&nbsp;&nbsp; when you pass memory size to malloc , it convert
it to a 32 byte multiple size, so it is exactly compatible with standard
C malloc,&nbsp; idem for free &amp; calloc...
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I have include the pid of the process
that allocated the memory block , like that I will implement a sort of
killmem(pid) function , which will free all the block allocated by a process,
based on his pid...
<p>&nbsp;&nbsp;&nbsp; I have done some timing on numerous allocation, and
I can say that it is pretty fast...
<br>&nbsp;&nbsp;&nbsp; In fact for this first version there is no multithreading
locking, for avoiding different process to allocate block at the same time...
<br>&nbsp;&nbsp;&nbsp; But I will do it very soon...
<p>&nbsp;&nbsp;&nbsp; OK...so to use these memory allocation progz...
<br>&nbsp;&nbsp;&nbsp; You have to call MemInit&nbsp; first... the C syntax
is MemInit (memaddr, memsize) , look in the source for ASM syntax...
<br>This function pass to the memory allocation core the adress(memaddr)
&amp; the size(memsize)&nbsp; of a physical memory block, that will be
used as the available memory for malloc, free, &amp; calloc...
<br>&nbsp;&nbsp;&nbsp; For example, if you want to use my clib with you
C program, you can for example allocate a block of memory of 5 MBytes with
standard malloc,&nbsp;&nbsp; then you call MemInit with the adress of the
block return by C malloc , and its size....
<br>&nbsp;&nbsp;&nbsp; Then it's all, you can now work only with my mem.alloc
versions of malloc, free, calloc,&nbsp; like you do with the system version...
<p><b><u><font color="#3366FF">itoa: convert int to ascii</font></u></b>
<p>here is the core of itoa, like you see it's short, this prog can convert
a 32 bit value give in eax , to a ascii string store in [edi], and it can
convert it in binary,decimal, hexadecimal , octal mode
<br>you just give the wanted mode in ecx (2,8,10,16 for example)
<br>I was using this algorithm to convert to decimal string, and I never
saw before that just in adding the
<br>cmp dl,'9'&nbsp; to process hexadecimal too , then you have an universal
int to ascii converter.
<br>I use it for my fprintf, to win space...
<p>itoa:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sub edx,edx
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; div ecx
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; test eax,eax
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jz short .print0
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push edx
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call itoa
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop edx
<br>.print0:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add dl,'0'
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp dl,'9'
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jle short .print1
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add dl,0x27
<br>.print1:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov [edi],dl
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc edi
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret
<p><b><u><font color="#3366FF">memset &amp; strlen</font></u></b>
<p>the version of strlen &amp; memset are the more optimized of all...
<br>I take some idea from the assembly journal , for the sized optimize
version of strlen, &amp; speed optimized version of memset...
<br>&nbsp;&nbsp;&nbsp; the size optimized version of strlen if only 10
bytes
<br>&nbsp;&nbsp;&nbsp; the speed optimized version of strlen process 1
character in 0.75 cycle, and it auto process misalign memory reference
without penalty...I think it is near optimal speed ...
<p>&nbsp;&nbsp;&nbsp; the speed optimized version of memset is fucking
speed too, &amp; if avoid misalign memory access too, it write ...I think
it near from optimal speed too..
<p><b><u><font color="#3366FF">fprint - first version</font></u></b>
<p>I have developped printf version for my OS I used it extensively , and
I think there is no bug
<br>for the moment fprintf can process:
<p>&nbsp;&nbsp;&nbsp; %s&nbsp; for string
<br>&nbsp;&nbsp;&nbsp; %d&nbsp; for decimal string
<br>&nbsp;&nbsp;&nbsp; %x for hexadecimal string
<br>&nbsp;&nbsp;&nbsp; %o for octal string
<br>&nbsp;&nbsp;&nbsp; %b for binary string
<br>&nbsp;&nbsp;&nbsp; \n&nbsp;&nbsp; line feed&nbsp; or you can use&nbsp;
db 10&nbsp; in assembler it's the same
<p>for the moment it is the only thing processed , more will come...
<br>I only use C style call for fprint , because there can be many args
, and passing them by registers was too hard..
<br>the string are null-terminated like in C
<br>fprintf(filedesc,string, args, .... )
<br>fprintf&nbsp; can write to STDOUT or file
<br>so I implement printf as a macro that do fprint(STDOUT, string, args,
...)
<p>&nbsp;&nbsp;&nbsp; I think that this fprintf version is compact &amp;
small , tell me what you think of it , &amp; if it is interesting to implement
all the printf&nbsp; stuff,&nbsp; or to do a compact version that just
handle the most useful things...
<p>&nbsp;&nbsp;&nbsp; My fprintf version, is compatible with C standard
one...
<p><b><u><font color="#3366FF">memcpy - the worst</font></u></b>
<p><font color="#330000">I haven't found any good optimization for memcpy,
because the source, &amp; dest must be dword aligned to be optimize, and
if one of the two if not aligned correctly you can't synchronize the two</font>
<br><font color="#330000">so I implement memcpy&nbsp; with rep movsb</font>
<br><font color="#330000">and I do a memcpyl&nbsp;&nbsp; with rep movsd&nbsp;&nbsp;
bu the source &amp; dest must be dword aligned or no speed gain will be
feel...</font>
<br>
<hr WIDTH="100%">
<center>
<h2>
<b><font color="#330000">OK</font></b></h2></center>

<hr WIDTH="100%">
<br><font color="#330000">so...</font>
<br><font color="#330000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; here
is the actual size of different compilation options on clib:</font>
<p><font color="#330000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SPEEDOPT &amp; C_CALL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ->&nbsp;&nbsp;
790 bytes</font>
<br><font color="#330000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SIZEOPT &amp; C_CALL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
->&nbsp;&nbsp;&nbsp; 618 bytes</font>
<p><font color="#330000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SPEEDOPT &amp; ASM_CALL&nbsp;&nbsp; ->&nbsp; 676 bytes</font>
<br><font color="#330000">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SIZEOPT &amp; ASM_CALL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -> 504
bytes</font>
<p><font color="#330000">so the SIZE OPT&nbsp; make wins 172 bytes for
the moment</font>
<p><font color="#330000">pretty small no ???</font>
<br>&nbsp;
</body>
</html>
